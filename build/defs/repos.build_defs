def fetch_jj_cmd(name:str, repo:str, url:str, remotes:list=[]):
    jj_repo_dir = f"{repo}.jj"
    
    repo_cmds = [
        "cd repos",
        f"if [ ! -d {jj_repo_dir} ]; then jj git clone {url} {jj_repo_dir}; fi"
    ]

    remote_cmds = map(lambda rem: f"if ! jj -R {jj_repo_dir} git remote list | awk -v r={rem.name} '\\\$1 == r' | grep -q {rem.name}; then jj -R {jj_repo_dir} git remote add {rem.name} {rem.url}; fi", remotes)

    sh_cmd(
        name = name,
        cmd = repo_cmds + remote_cmds
    )

    jj_repo(name = "repo", repo = repo)

def jj_repo(name:str, repo:str, version:str=None):
    version_flag = ""
    version_suffix = ""

    if version:
        clean_version = version.replace("/", "-")
        version_flag = f"-r {version}"
        version_suffix = f"--{version}"

    jj_repo = f"{repo}.jj"
    jj_workspace = f"{repo}{version_suffix}.jj"
    rev = version or "@"
    
    cmd = " && ".join([
        # forget workspace at first, in case a previous run failed
        f"jj -R $(plz query reporoot)/repos/{jj_repo} workspace forget __plz 2> /dev/null || true",
        f"jj -R $(plz query reporoot)/repos/{jj_repo} workspace add -r {rev} --name __plz{version_suffix} {jj_workspace}",
        f"jj -R $(plz query reporoot)/repos/{jj_repo} workspace forget __plz{version_suffix}",
        f"rm -rf {jj_workspace}/.jj"
    ])

    workspace_rule = build_rule(
        name = name,
        cmd = cmd,
        outs = [jj_workspace],
        _subrepo = True
    )

    return subrepo(
        name = name,
        dep = workspace_rule
    )
