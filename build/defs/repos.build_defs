def fetch_repos(repos:list):
    for r in repos:
        repo_cmds = [
            f"cd ./$(dir :fetch-{r.name})",
            f"if [ ! -d {r.name}.jj ]; then jj git clone {r.url} {r.name}.jj; fi",
            f"cd {r.name}.jj"
        ]

        remotes = r.get("remotes", [])
        remote_cmds = map(lambda rem: f"if ! jj git remote list | awk -v r={rem.name} '\\\$1 == r' | grep -q {rem.name}; then jj git remote add {rem.name} {rem.url}; fi", remotes)

        sh_cmd(
            name = f"fetch-{r.name}",
            cmd = repo_cmds + remote_cmds
        )

        jj_repo(name = r.name)

    deps = map(lambda r : f":fetch-{r.name}", repos)
    cmds = map(lambda d : f"sh $(out_location {d})", deps)

    sh_cmd(
        name = "fetch",
        deps = deps,
        cmd = cmds,
        visibility = ["PUBLIC"]
    )

def jj_repo(name:str, version:str=None):
    target_name = name
    version_flag = ""

    if version:
        clean_version = version.replace("/", "-")
        target_name = f"{name}-{clean_version}"
        version_flag = f"-r {version}"

    cmd = " && ".join([
        # forget workspace at first, in case a previous run failed
        f"jj -R $(plz query reporoot)/repos/{name}.jj workspace forget __plz 2> /dev/null || true",
        f"jj -R $(plz query reporoot)/repos/{name}.jj workspace add --name __plz {version_flag} {target_name}",
        f"jj -R $(plz query reporoot)/repos/{name}.jj workspace forget __plz",
        f"rm -rf {target_name}/.jj"
    ])

    workspace_rule = build_rule(
        name = target_name,
        cmd = cmd,
        outs = [target_name],
        _subrepo = True
    )

    return subrepo(
        name = target_name,
        dep = workspace_rule
    )
